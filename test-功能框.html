<!--功能框，右键点开，选择需要的功能-->
<!--同时有一个放置翻译结果的sticky小框-->
<!--和显示搜索结果的小卡片-->
<!--只是为了测试，美观……一言难尽-->
<!DOCTYPE html>
<html>
    <head>
        <title>FunctionBox</title>
        <style>
            #options{
                display: none;
                position: absolute;
                background-color: #f9f9f9;
                min-width: 160px;
                box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            }
            #options input{
                border:none;
                width:100%; 
                height: 30px;
                text-align: center;
                display:block;
            }
            #options input:hover{
                background-color:#d4d0d0;
            }
            #floatingWin{
                border:2px solid beige;
                background: rgb(215, 236, 243);
                font:15px arial,san-serif;
                width:auto;height:auto;
                text-align: center;
                top:38px; left:8px;
                position:fixed;
                display:none;
                z-index:10;
                box-shadow:0px 8px 16px 0px rgba(0,0,0,0.2);
            }
            #floatingWin span:hover{
                background-color: rgb(184, 235, 252);
            }
            #explainAns{
                background-color: white;
                font:14px black arial,san-serif;
                word-break:break-all;
                width:250px;
                display: none;
                border:2px solid burlywood;
                position:absolute;
                z-index:10;
                box-shadow:0px 8px 16px 0px rgba(0,0,0,0.2);
            }
        </style>
        <script>
            function showOptions(){
                var x=document.getElementById("options");
                x.style.display="block";
                x.style.left=window.event.clientX+document.documentElement.scrollLeft+10+'px';
                x.style.top=window.event.clientY+document.documentElement.scrollTop+5+'px';
                x.style.position="absolute";
                document.body.appendChild(x);
            }
            function hide(mydiv){
                document.getElementById(mydiv).style.display="none";
            }
            function clearDiv(){
                document.getElementById("translateAns").textContent="";
                document.getElementById("floatingWin").style.display="none";                
            }
            function translate(){
                document.getElementById("floatingWin").style.display="block";
            }
            function explain(){
                var y=document.getElementById("explainAns");
                document.getElementById('explainAns').style.display='block';
                document.getElementById('explainAns').innerHTML="dsiuhiceroifofhxhfiurhfxunwfiocewr7fyecwioryficeourfye8r7398720709ciufwhxiufhreuiyry8r394chenggonglema?eiwuexywiruwyqoixhuiewzmiqwiffiorfoerie0r90eriifodidsops9ewew09e0wdsoioidsoidosdisoidjsoijoijffueywuwuqingfwngifapofiuxwqopuxqwpywfyeruifhskhdfoakfuisyoiuehiejndvkjhcjlrfksuhiouywioeyfwuimxhmkskdjhkzsdfueryfchfiwu";
                document.getElementById('options').style.display="none";
                y.style.display="block";
                y.style.left=window.event.clientX+document.documentElement.scrollLeft+10+'px';
                y.style.top=window.event.clientY+document.documentElement.scrollTop+5+'px';
                y.style.position="absolute";
                document.body.appendChild(y);
            }
        </script>
    </head>
    <body>
        <div style="position:relative;">
        <p oncontextmenu="showOptions()" onclick="hide('options')">
            In the time since the 1986 edition of this book, the world of compiler design has changed significantly.
            Programming languages have evolved to present new compilation problems. Computer architectures offer 
            a variety of resources of which the compiler designer must take advantage. Perhaps most interestingly, 
            the venerable technology of code optimization has found use outside compilers. It is now used in tools
            that find bugs in software, and most importantly, find security holes in existing code. And much of 
            the "front-end" technology grammars, regular expressions, parsers, and syntax-directed translators - 
            are still in wide use. Thus, our philosophy from previous versions of the book has not changed. We 
            recognize that few readers will build, or even maintain, a compiler for a major programming language. 
            Yet the models, theory, and algorithms associated with a compiler can be applied to a wide range of 
            problems in software design and software development. We therefore emphasize problems that are most 
            commonly encountered in designing a language processor, regardless of the source language or target machine. 
            In the time since the 1986 edition of this book, the world of compiler design has changed significantly.
            Programming languages have evolved to present new compilation problems. Computer architectures offer 
            a variety of resources of which the compiler designer must take advantage. Perhaps most interestingly, 
            the venerable technology of code optimization has found use outside compilers. It is now used in tools
            that find bugs in software, and most importantly, find security holes in existing code. And much of 
            the "front-end" technology grammars, regular expressions, parsers, and syntax-directed translators - 
            are still in wide use. Thus, our philosophy from previous versions of the book has not changed. We 
            recognize that few readers will build, or even maintain, a compiler for a major programming language. 
            Yet the models, theory, and algorithms associated with a compiler can be applied to a wide range of 
            problems in software design and software development. We therefore emphasize problems that are most 
            commonly encountered in designing a language processor, regardless of the source language or target machine.
            In the time since the 1986 edition of this book, the world of compiler design has changed significantly.
            Programming languages have evolved to present new compilation problems. Computer architectures offer 
            a variety of resources of which the compiler designer must take advantage. Perhaps most interestingly, 
            the venerable technology of code optimization has found use outside compilers. It is now used in tools
            that find bugs in software, and most importantly, find security holes in existing code. And much of 
            the "front-end" technology grammars, regular expressions, parsers, and syntax-directed translators - 
            are still in wide use. Thus, our philosophy from previous versions of the book has not changed. We 
            recognize that few readers will build, or even maintain, a compiler for a major programming language. 
            Yet the models, theory, and algorithms associated with a compiler can be applied to a wide range of 
            problems in software design and software development. We therefore emphasize problems that are most 
            commonly encountered in designing a language processor, regardless of the source language or target machine.
            In the time since the 1986 edition of this book, the world of compiler design has changed significantly.
            Programming languages have evolved to present new compilation problems. Computer architectures offer 
            a variety of resources of which the compiler designer must take advantage. Perhaps most interestingly, 
            the venerable technology of code optimization has found use outside compilers. It is now used in tools
            that find bugs in software, and most importantly, find security holes in existing code. And much of 
            the "front-end" technology grammars, regular expressions, parsers, and syntax-directed translators - 
            are still in wide use. Thus, our philosophy from previous versions of the book has not changed. We 
            recognize that few readers will build, or even maintain, a compiler for a major programming language. 
            Yet the models, theory, and algorithms associated with a compiler can be applied to a wide range of 
            problems in software design and software development. We therefore emphasize problems that are most 
            commonly encountered in designing a language processor, regardless of the source language or target machine.
            In the time since the 1986 edition of this book, the world of compiler design has changed significantly.
            Programming languages have evolved to present new compilation problems. Computer architectures offer 
            a variety of resources of which the compiler designer must take advantage. Perhaps most interestingly, 
            the venerable technology of code optimization has found use outside compilers. It is now used in tools
            that find bugs in software, and most importantly, find security holes in existing code. And much of 
            the "front-end" technology grammars, regular expressions, parsers, and syntax-directed translators - 
            are still in wide use. Thus, our philosophy from previous versions of the book has not changed. We 
            recognize that few readers will build, or even maintain, a compiler for a major programming language. 
            Yet the models, theory, and algorithms associated with a compiler can be applied to a wide range of 
            problems in software design and software development. We therefore emphasize problems that are most 
            commonly encountered in designing a language processor, regardless of the source language or target machine.
            In the time since the 1986 edition of this book, the world of compiler design has changed significantly.
            Programming languages have evolved to present new compilation problems. Computer architectures offer 
            a variety of resources of which the compiler designer must take advantage. Perhaps most interestingly, 
            the venerable technology of code optimization has found use outside compilers. It is now used in tools
            that find bugs in software, and most importantly, find security holes in existing code. And much of 
            the "front-end" technology grammars, regular expressions, parsers, and syntax-directed translators - 
            are still in wide use. Thus, our philosophy from previous versions of the book has not changed. We 
            recognize that few readers will build, or even maintain, a compiler for a major programming language. 
            Yet the models, theory, and algorithms associated with a compiler can be applied to a wide range of 
            problems in software design and software development. We therefore emphasize problems that are most 
            commonly encountered in designing a language processor, regardless of the source language or target machine. 
            In the time since the 1986 edition of this book, the world of compiler design has changed significantly.
            Programming languages have evolved to present new compilation problems. Computer architectures offer 
            a variety of resources of which the compiler designer must take advantage. Perhaps most interestingly, 
            the venerable technology of code optimization has found use outside compilers. It is now used in tools
            that find bugs in software, and most importantly, find security holes in existing code. And much of 
            the "front-end" technology grammars, regular expressions, parsers, and syntax-directed translators - 
            are still in wide use. Thus, our philosophy from previous versions of the book has not changed. We 
            recognize that few readers will build, or even maintain, a compiler for a major programming language. 
            Yet the models, theory, and algorithms associated with a compiler can be applied to a wide range of 
            problems in software design and software development. We therefore emphasize problems that are most 
            commonly encountered in designing a language processor, regardless of the source language or target machine.
            In the time since the 1986 edition of this book, the world of compiler design has changed significantly.
            Programming languages have evolved to present new compilation problems. Computer architectures offer 
            a variety of resources of which the compiler designer must take advantage. Perhaps most interestingly, 
            the venerable technology of code optimization has found use outside compilers. It is now used in tools
            that find bugs in software, and most importantly, find security holes in existing code. And much of 
            the "front-end" technology grammars, regular expressions, parsers, and syntax-directed translators - 
            are still in wide use. Thus, our philosophy from previous versions of the book has not changed. We 
            recognize that few readers will build, or even maintain, a compiler for a major programming language. 
            Yet the models, theory, and algorithms associated with a compiler can be applied to a wide range of 
            problems in software design and software development. We therefore emphasize problems that are most 
            commonly encountered in designing a language processor, regardless of the source language or target machine.
            In the time since the 1986 edition of this book, the world of compiler design has changed significantly.
            Programming languages have evolved to present new compilation problems. Computer architectures offer 
            a variety of resources of which the compiler designer must take advantage. Perhaps most interestingly, 
            the venerable technology of code optimization has found use outside compilers. It is now used in tools
            that find bugs in software, and most importantly, find security holes in existing code. And much of 
            the "front-end" technology grammars, regular expressions, parsers, and syntax-directed translators - 
            are still in wide use. Thus, our philosophy from previous versions of the book has not changed. We 
            recognize that few readers will build, or even maintain, a compiler for a major programming language. 
            Yet the models, theory, and algorithms associated with a compiler can be applied to a wide range of 
            problems in software design and software development. We therefore emphasize problems that are most 
            commonly encountered in designing a language processor, regardless of the source language or target machine.
            In the time since the 1986 edition of this book, the world of compiler design has changed significantly.
            Programming languages have evolved to present new compilation problems. Computer architectures offer 
            a variety of resources of which the compiler designer must take advantage. Perhaps most interestingly, 
            the venerable technology of code optimization has found use outside compilers. It is now used in tools
            that find bugs in software, and most importantly, find security holes in existing code. And much of 
            the "front-end" technology grammars, regular expressions, parsers, and syntax-directed translators - 
            are still in wide use. Thus, our philosophy from previous versions of the book has not changed. We 
            recognize that few readers will build, or even maintain, a compiler for a major programming language. 
            Yet the models, theory, and algorithms associated with a compiler can be applied to a wide range of 
            problems in software design and software development. We therefore emphasize problems that are most 
            commonly encountered in designing a language processor, regardless of the source language or target machine.</p>
            <div id="options">
                <input type="button" value="translate" onclick="translate()">
                <input type="button" value="highlight" onclick="highlight()">
                <input type="button" value="explain" onclick="explain()">
                <input type="button" value="summarize" onclick="summarize()">
            </div>
        </div>
    <!--FLoating window for translate answer-->
    <div id="floatingWin">
        <div style="text-align:right; cursor:default; height:3px;">
            <span style="color:gray; font-size:20px;" onclick="hideDiv('floatingWin')">~</span>
            <span style="color:red; font-size:20px;" onclick="clearDiv('translateAns','floatingWin')">X</span>
        </div>
        <div><br></div>
        <textarea style="overflow: auto; background-color: white;color:black;" cols="30" rows="24" name="translateAns" id="translateAns"></textarea>
    </div>
        <!--explain 小卡片-->
        <p id="explainAns"></p>    <!--FLoating card for explain answer-->
    </body>
</html>